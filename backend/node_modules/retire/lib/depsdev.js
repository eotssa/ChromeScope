"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkOSV = void 0;
const https_1 = __importDefault(require("https"));
const retire_1 = require("./retire");
function loadJson(url, options) {
    options.log.debug('Downloading ' + url + ' ...');
    return new Promise((resolve, reject) => {
        const req = https_1.default.request(url, (res) => {
            if (res.statusCode == 404)
                return resolve(undefined);
            if (res.statusCode != 200) {
                return reject('HTTP ' + res.statusCode + ' ' + res.statusMessage + ' for ' + url);
            }
            const data = [];
            res.on('data', (c) => data.push(c));
            res.on('end', () => {
                const result = Buffer.concat(data).toString();
                resolve(JSON.parse(result));
            });
        });
        req.on('error', (err) => {
            reject(err);
        });
        req.end();
    });
}
function getVulnerabilities(packageName, version, options) {
    return loadJson(`https://api.deps.dev/v3alpha/systems/npm/packages/${packageName}/versions/${version}`, options);
}
function scoreToSeverity(score) {
    if (score > 7)
        return 'high';
    if (score > 4)
        return 'medium';
    return 'low';
}
function loadAdvisory(packageName, version, id, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const osvAdvisory = yield loadJson(`https://api.osv.dev/v1/vulns/${id}`, options);
        const advisory = yield loadJson(`https://api.deps.dev/v3alpha/advisories/${id}`, options);
        if (!advisory || !osvAdvisory)
            return [];
        const simplifiedRepo = {
            [packageName]: {
                vulnerabilities: osvAdvisory.affected
                    .map(({ ranges }) => ranges.map(({ events }) => {
                    var _a, _b;
                    return ({
                        atOrAbove: events[0].introduced,
                        below: events[0].fixed,
                        severity: scoreToSeverity(advisory.cvss3Score),
                        cwe: (_b = (_a = osvAdvisory.database_specific) === null || _a === void 0 ? void 0 : _a.cwe_ids) !== null && _b !== void 0 ? _b : [],
                        identifiers: {
                            githubID: id,
                            CVE: osvAdvisory.aliases.filter((x) => x.startsWith('CVE-')),
                            summary: advisory.title,
                        },
                        info: osvAdvisory.references.map(({ url }) => url),
                    });
                }))
                    .reduce((a, b) => a.concat(b), []),
                extractors: {},
            },
        };
        return (0, retire_1.check)(packageName, version, simplifiedRepo);
    });
}
function checkOSV(packageName, version, options) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const versionInfo = yield getVulnerabilities(packageName, version, options);
            if (!versionInfo)
                return [];
            if (versionInfo.advisoryKeys.length == 0)
                return [];
            const comps = yield Promise.all(versionInfo.advisoryKeys.map(({ id }) => loadAdvisory(packageName, version, id, options)));
            const flattened = comps.reduce((a, b) => a.concat(b), []);
            return flattened.map((x) => { var _a; return (_a = x.vulnerabilities) !== null && _a !== void 0 ? _a : []; }).reduce((a, b) => a.concat(b), []);
        }
        catch (e) {
            options.log.warn('Error checking OSV: ' + e);
            return [];
        }
    });
}
exports.checkOSV = checkOSV;
