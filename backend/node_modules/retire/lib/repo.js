"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.loadrepositoryFromFile = exports.loadrepository = exports.asbowerrepo = void 0;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const http = __importStar(require("http"));
const https = __importStar(require("https"));
const retire = __importStar(require("./retire"));
const URL = __importStar(require("url"));
const proxy_agent_1 = require("proxy-agent");
function loadJson(url, options) {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            options.log.info('Downloading ' + url + ' ...');
            const reqOptions = Object.assign(Object.assign({}, URL.parse(url)), { method: 'GET' });
            const proxyUri = options.proxy || process.env.http_proxy;
            if (proxyUri) {
                reqOptions.agent = new proxy_agent_1.ProxyAgent({
                    getProxyForUrl: () => proxyUri,
                });
            }
            if (options.insecure) {
                reqOptions.rejectUnauthorized = false;
            }
            if (options.cacertbuf) {
                reqOptions.ca = [options.cacertbuf];
            }
            const req = (url.startsWith('http:') ? http : https).get(reqOptions, (res) => {
                if (res.statusCode != 200)
                    return reject(`Error downloading: ${url}: HTTP ${res.statusCode} ${res.statusMessage}`);
                const data = [];
                res.on('data', (c) => data.push(c));
                res.on('end', () => {
                    let d = Buffer.concat(data).toString();
                    d = options.process ? options.process(d) : d;
                    resolve(JSON.parse(d));
                });
            });
            req.on('error', (e) => reject(`Error downloading: ${url}: ${e}`));
            req.end();
        });
    });
}
function loadJsonFromFile(file, options) {
    return __awaiter(this, void 0, void 0, function* () {
        options.log.debug('Reading ' + file + ' ...');
        return new Promise((resolve, reject) => {
            fs.readFile(file, { encoding: 'utf8' }, (err, data) => {
                if (err) {
                    return reject(err.toString());
                }
                data = options.process ? options.process(data) : data;
                resolve(JSON.parse(data));
            });
        });
    });
}
function loadFromCache(url, cachedir, options) {
    return __awaiter(this, void 0, void 0, function* () {
        const cacheIndex = path.resolve(cachedir, 'index.json');
        if (!fs.existsSync(cachedir))
            fs.mkdirSync(cachedir);
        const cache = fs.existsSync(cacheIndex) ? JSON.parse(fs.readFileSync(cacheIndex, 'utf-8')) : {};
        const now = new Date().getTime();
        if (cache[url]) {
            if (now - cache[url].date < 60 * 60 * 1000) {
                options.log.info('Loading from cache: ' + url);
                return loadJsonFromFile(path.resolve(cachedir, cache[url].file), options);
            }
            else {
                if (fs.existsSync(path.resolve(cachedir, cache[url].date + '.json'))) {
                    try {
                        fs.unlinkSync(path.resolve(cachedir, cache[url].date + '.json'));
                    }
                    catch (error) {
                        if (error != null && typeof error == 'object' && 'code' in error && error.code !== 'ENOENT') {
                            throw error;
                        }
                        else {
                            console.warn('Could not delete cache. Ignore this error if you are running multiple retire.js in parallel');
                        }
                    }
                }
            }
        }
        const data = yield loadJson(url, options);
        cache[url] = { date: now, file: now + '.json' };
        fs.writeFileSync(path.resolve(cachedir, cache[url].file), JSON.stringify(data), { encoding: 'utf8' });
        fs.writeFileSync(cacheIndex, JSON.stringify(cache), { encoding: 'utf8' });
        return data;
    });
}
function asbowerrepo(jsRepo) {
    const result = {};
    Object.keys(jsRepo).map((k) => {
        (jsRepo[k].bowername || [k]).map((b) => {
            result[b] = result[b] || { vulnerabilities: [] };
            result[b].vulnerabilities = result[b].vulnerabilities.concat(jsRepo[k].vulnerabilities);
        });
    });
    return result;
}
exports.asbowerrepo = asbowerrepo;
function loadrepository(repoUrl, options) {
    return __awaiter(this, void 0, void 0, function* () {
        //options = utils.extend(options, { process : retire.replaceVersion });
        options = Object.assign(Object.assign({}, options), { process: retire.replaceVersion });
        if (options.nocache) {
            return yield loadJson(repoUrl, options);
        }
        return yield loadFromCache(repoUrl, options.cachedir, options);
    });
}
exports.loadrepository = loadrepository;
function loadrepositoryFromFile(filepath, options) {
    return __awaiter(this, void 0, void 0, function* () {
        options = Object.assign(Object.assign({}, options), { process: retire.replaceVersion });
        return yield loadJsonFromFile(filepath, options);
    });
}
exports.loadrepositoryFromFile = loadrepositoryFromFile;
