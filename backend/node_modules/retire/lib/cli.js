#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
Object.defineProperty(exports, "__esModule", { value: true });
const utils = __importStar(require("./utils"));
const commander_1 = require("commander");
const retire = __importStar(require("./retire"));
const repo = __importStar(require("./repo"));
const resolve = __importStar(require("./resolve"));
const scanner = __importStar(require("./scanner"));
const reporting = __importStar(require("./reporting"));
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const ansi_colors_1 = __importDefault(require("ansi-colors"));
const events_1 = require("events");
const types_1 = require("./types");
const z = __importStar(require("zod"));
const events = new events_1.EventEmitter();
let failProcess = false;
const defaultIgnoreFiles = ['.retireignore', '.retireignore.json'];
if (process.argv.includes('--node') || process.argv.includes('-n')) {
    console.log('Error: retire.js no longer supports scanning node packages. Use npm audit instead.');
    process.exit(1);
}
/*
 * Parse command line flags.
 */
const prg = commander_1.program
    .version(retire.version)
    .option('-v, --verbose', 'Show identified files (by default only vulnerable files are shown)')
    .option('-c, --nocache', "Don't use local cache")
    .option('--jspath <path>', 'Folder to scan for javascript files (deprecated)')
    .option('--path <path>', 'Folder to scan for javascript files')
    .option('--jsrepo <path|url>', "Local or internal version of repo. Can be multiple comma separated. Default: 'central')")
    .option('--cachedir <path>', 'Path to use for local cache instead of /tmp/.retire-cache')
    .option('--proxy <url>', 'Proxy url (http://some.host:8080)')
    .option('--outputformat <format>', 'Valid formats: text, json, jsonsimple, depcheck (experimental), cyclonedx and cyclonedxJSON')
    .option('--outputpath <path>', 'File to which output should be written')
    .option('--ignore <paths>', 'Comma delimited list of paths to ignore')
    .option('--ignorefile <path>', 'Custom ignore file, defaults to .retireignore / .retireignore.json')
    .option('--severity <level>', 'Specify the bug severity level from which the process fails. Allowed levels none, low, medium, high, critical. Default: none')
    .option('--exitwith <code>', 'Custom exit code (default: 13) when vulnerabilities are found')
    .option('--colors', 'Enable color output (console output only)')
    .option('--insecure', 'Enable fetching remote jsrepo/noderepo files from hosts using an insecure or self-signed SSL (TLS) certificate')
    .option('--ext <extensions>', 'Comma separated list of file extensions for JavaScript files. The default is "js"')
    .option('--cacert <path>', 'Use the specified certificate file to verify the peer used for fetching remote jsrepo/noderepo files')
    .option('--includeOsv', 'Include OSV advisories in the output')
    .parse()
    .opts();
const colorwarn = prg.colors ? ansi_colors_1.default.red : (x) => x;
const jsrepolocation = ((_a = prg.jsrepo) !== null && _a !== void 0 ? _a : "'central'")
    .split(',')
    .map((x) => x === "'central'" ? 'https://raw.githubusercontent.com/RetireJS/retire.js/master/repository/jsrepository.json' : x);
const ignorefile = (_b = prg.ignoreFile) !== null && _b !== void 0 ? _b : defaultIgnoreFiles.filter((x) => fs_1.default.existsSync(x))[0];
const scanpath = (_d = (_c = prg.path) !== null && _c !== void 0 ? _c : prg.jspath) !== null && _d !== void 0 ? _d : '.';
const log = reporting.open({
    colors: !!prg.colors,
    colorwarn,
    jsRepo: jsrepolocation.join(', '),
    outputformat: prg.outputformat,
    outputpath: prg.outputpath,
    path: scanpath,
    verbose: !!prg.verbose,
});
const severity = (_e = prg.severity) !== null && _e !== void 0 ? _e : 'none';
if (!(severity in types_1.severityLevels)) {
    exitWithError(`Error: Invalid severity level (${severity}). Valid levels are: ${Object.keys(types_1.severityLevels).join(', ')}`);
}
const config = {
    path: scanpath,
    ignore: {
        paths: [],
        pathsAsString: (_h = (_g = (_f = prg.ignore) === null || _f === void 0 ? void 0 : _f.split(',')) === null || _g === void 0 ? void 0 : _g.map((x) => path_1.default.resolve(x))) !== null && _h !== void 0 ? _h : [],
        descriptors: [],
    },
    colorwarn,
    nocache: prg.nocache ? true : false,
    cachedir: (_j = prg.cachedir) !== null && _j !== void 0 ? _j : path_1.default.resolve(os_1.default.tmpdir(), '.retire-cache/'),
    log: log,
    severity: severity,
    exitwith: (_k = prg.exitwith) !== null && _k !== void 0 ? _k : 13,
    includeOsv: !!prg.includeOsv,
    verbose: !!prg.verbose,
    proxy: prg.proxy,
};
log.info(`retire.js v${retire.version}`);
function exitWithError(msg) {
    log.error(config.colorwarn(msg));
    process.exitCode = 1;
    log.close();
}
if (prg.cacert) {
    if (!fs_1.default.existsSync(prg.cacert)) {
        exitWithError(`Error: Could not read cacert file: ${prg.cacert}`);
    }
    config.cacertbuf = fs_1.default.readFileSync(prg.cacert);
}
const ignoreFileParser = z.array(z
    .object({
    justification: z.string(),
})
    .and(z
    .object({
    path: z.string(),
})
    .or(z.object({
    component: z.string(),
    version: z.string().optional(),
    identifiers: z.record(z.string(), z.string()).optional(),
}))));
if (ignorefile) {
    if (!fs_1.default.existsSync(ignorefile)) {
        exitWithError(`Error: Could not read ignore file: ${ignorefile}`);
    }
    if (ignorefile.substr(-5) === '.json') {
        try {
            config.ignore.descriptors = ignoreFileParser.parse(JSON.parse(fs_1.default.readFileSync(ignorefile, 'utf-8')));
        }
        catch (e) {
            exitWithError(`Error: Invalid ignore file: ${ignorefile}`);
        }
        const ignoredPaths = (_o = (_m = (_l = config.ignore.descriptors) === null || _l === void 0 ? void 0 : _l.map((x) => ('path' in x ? x.path : undefined))) === null || _m === void 0 ? void 0 : _m.filter((x) => x != undefined)) !== null && _o !== void 0 ? _o : [];
        config.ignore.pathsAsString = config.ignore.pathsAsString.concat(ignoredPaths);
    }
    else {
        const lines = fs_1.default
            .readFileSync(ignorefile, 'utf-8')
            .split(/\r\n|\n/g)
            .filter((e) => e !== '');
        const ignored = lines.map((e) => {
            return e[0] === '@' ? e.slice(1) : path_1.default.resolve(e);
        });
        config.ignore.pathsAsString = config.ignore.pathsAsString.concat(ignored);
    }
}
config.ignore.paths = config.ignore.pathsAsString
    .map((p) => p.replace(/[.+?^${}()|[\]\\]/g, '\\$&'))
    .map((p) => p.replace(/[*]{1,2}/g, (a) => (a.length == 2 ? '.*' : '[^/]*')))
    .map((s) => new RegExp(s));
scanner.on('vulnerable-dependency-found', (result) => {
    const levels = result.results.map((r) => {
        return r.vulnerabilities
            ? r.vulnerabilities.map((v) => {
                var _a;
                return types_1.severityLevels[(_a = v.severity) !== null && _a !== void 0 ? _a : 'critical'];
            })
            : [];
    });
    const severity = utils.flatten(levels).reduce((x, y) => (x > y ? x : y));
    if (severity >= types_1.severityLevels[config.severity]) {
        failProcess = true;
    }
});
scanner.on('vulnerable-dependency-found', log.logVulnerableDependency);
scanner.on('dependency-found', log.logDependency);
events.on('scan-done', () => {
    process.exitCode = failProcess ? config.exitwith : 0;
    log.close();
});
process.on('uncaughtException', (err, ...rest) => {
    console.warn('Exception caught: ', err, rest);
    console.warn(err.stack);
    process.exit(1);
});
events.on('stop', (err) => {
    exitWithError(err);
});
Promise.all(jsrepolocation.map((jsr) => jsr.match(/^https?:\/\//) ? repo.loadrepository(jsr, config) : repo.loadrepositoryFromFile(jsr, config)))
    .then((jsRepos) => {
    resolve
        .scanJsFiles(config.path, config)
        .on('jsfile', (file) => {
        jsRepos.forEach((jsRepo) => {
            scanner.scanJsFile(file, jsRepo, config);
        });
    })
        .on('bowerfile', (bowerfile) => {
        jsRepos.forEach((jsRepo) => {
            const bowerRepo = repo.asbowerrepo(jsRepo);
            scanner.scanBowerFile(bowerfile, bowerRepo, config);
        });
    })
        .on('end', () => {
        events.emit('scan-done');
    });
})
    .catch((e) => events.emit('stop', e));
