"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.on = exports.scanBowerFile = exports.scanJsFile = void 0;
const events_1 = require("events");
const retire = __importStar(require("./retire"));
const fs = __importStar(require("fs"));
const crypto = __importStar(require("crypto"));
const path = __importStar(require("path"));
const depsdev_1 = require("./depsdev");
const events = new events_1.EventEmitter();
const hash = {
    sha1: (data) => {
        const shasum = crypto.createHash('sha1');
        shasum.update(data);
        return shasum.digest('hex');
    },
};
function emitResults(finding, options) {
    if (options.includeOsv === true) {
        Promise.all(finding.results.map((r) => (0, depsdev_1.checkOSV)(r.component, r.version, options).then((v) => { var _a; return (r.vulnerabilities = ((_a = r.vulnerabilities) !== null && _a !== void 0 ? _a : []).concat(v)); }))).then(() => filterAndEmitResults(finding, options));
    }
    else {
        filterAndEmitResults(finding, options);
    }
}
function getIdentifiers(v) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return ((_b = (_a = v.identifiers) === null || _a === void 0 ? void 0 : _a.CVE) !== null && _b !== void 0 ? _b : [])
        .concat((_d = (_c = v.identifiers) === null || _c === void 0 ? void 0 : _c.bug) !== null && _d !== void 0 ? _d : [])
        .concat((_f = (_e = v.identifiers) === null || _e === void 0 ? void 0 : _e.issue) !== null && _f !== void 0 ? _f : [])
        .concat((_h = (_g = v.identifiers) === null || _g === void 0 ? void 0 : _g.githubID) !== null && _h !== void 0 ? _h : []);
}
function uniqueVulnerabilities(vulnerabilities) {
    if (!vulnerabilities)
        return undefined;
    const unique = [];
    for (const v of vulnerabilities) {
        if (!unique.some((u) => getIdentifiers(u).some((i) => getIdentifiers(v).includes(i)))) {
            unique.push(v);
        }
    }
    return unique;
}
function filterAndEmitResults(finding, options) {
    finding.results.forEach((r) => (r.vulnerabilities = uniqueVulnerabilities(r.vulnerabilities)));
    if (options.ignore)
        removeIgnored(finding.results, options.ignore);
    if (finding.results.length == 0)
        return;
    if (retire.isVulnerable(finding.results)) {
        events.emit('vulnerable-dependency-found', finding);
    }
    else {
        events.emit('dependency-found', finding);
    }
}
function shouldIgnorePath(fileSpecs, ignores) {
    var _a, _b;
    return ((_b = (_a = ignores.paths) === null || _a === void 0 ? void 0 : _a.some((i) => {
        return fileSpecs.some((j) => i.test(j) || i.test(path.resolve(j)));
    })) !== null && _b !== void 0 ? _b : false);
}
function removeIgnored(results, ignores) {
    if (!('descriptors' in ignores))
        return;
    results.forEach((r) => {
        var _a, _b;
        if (!('vulnerabilities' in r))
            return;
        (_a = ignores.descriptors) === null || _a === void 0 ? void 0 : _a.filter((d) => 'component' in d).forEach((i) => {
            var _a;
            if (r.component !== i.component)
                return;
            if (i.version && r.version !== i.version)
                return;
            if (i.severity) {
                //Remove vulnerabilities with the severity we want to drop
                r.vulnerabilities = (_a = r.vulnerabilities) === null || _a === void 0 ? void 0 : _a.filter((v) => v.severity != i.severity);
                return;
            }
            if (i.identifiers) {
                removeIgnoredVulnerabilitiesByIdentifier(Object.assign({}, i.identifiers), r);
                return;
            }
            r.vulnerabilities = [];
        });
        if (((_b = r.vulnerabilities) === null || _b === void 0 ? void 0 : _b.length) === 0)
            delete r.vulnerabilities;
    });
}
function removeIgnoredVulnerabilitiesByIdentifier(identifiers, result) {
    var _a;
    result.vulnerabilities = (_a = result.vulnerabilities) === null || _a === void 0 ? void 0 : _a.filter((v) => {
        if (!('identifiers' in v))
            return true;
        return !Object.entries(identifiers || {}).every(([key, value]) => hasIdentifier(Object.assign({}, v.identifiers), key, value));
    });
}
function hasIdentifier(identifiers, key, value) {
    if (!(key in identifiers))
        return false;
    const identifier = identifiers[key];
    return Array.isArray(identifier) ? identifier.some((x) => x === value) : identifier === value;
}
function scanJsFile(file, repo, options) {
    if (options.ignore && shouldIgnorePath([file], options.ignore)) {
        return;
    }
    let results = retire.scanFileName(file, repo);
    if (!results || results.length === 0) {
        results = retire.scanFileContent(fs.readFileSync(file, 'utf-8'), repo, hash);
    }
    emitResults({ file: file, results: results }, options);
}
exports.scanJsFile = scanJsFile;
function scanBowerFile(file, repo, options) {
    if (options.ignore && shouldIgnorePath([file], options.ignore)) {
        return;
    }
    try {
        const bower = JSON.parse(fs.readFileSync(file, 'utf-8'));
        if (bower.version) {
            const results = retire.check(bower.name, bower.version, repo);
            emitResults({ file: file, results: results }, options);
        }
    }
    catch (e) {
        options.log.warn(`Could not parse file: ${file}`);
    }
}
exports.scanBowerFile = scanBowerFile;
function on(event, handler) {
    events.on(event, handler);
}
exports.on = on;
